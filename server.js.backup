const express = require('express');
const TelegramBot = require('node-telegram-bot-api');
const WebSocket = require('ws');
const axios = require('axios');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static('public'));

// Create bot instance with webhook
const bot = new TelegramBot(process.env.BOT_TOKEN, { polling: false });

// WebSocket server for real-time updates
const wss = new WebSocket.Server({ port: 8080 });

// Store active connections
const connections = new Map();
const userSessions = new Map();

// WebSocket connection handling
wss.on('connection', (ws, req) => {
  console.log('🔌 New WebSocket connection established');
  
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);
      console.log('📨 WebSocket message received:', data);
      
      // Handle different message types
      switch (data.type) {
        case 'auth':
          // Authenticate user and store connection
          const userId = data.userId;
          connections.set(userId, ws);
          userSessions.set(userId, {
            ws: ws,
            subscriptions: new Set(),
            lastActivity: Date.now()
          });
          ws.send(JSON.stringify({ type: 'auth_success', userId }));
          console.log(`✅ User ${userId} authenticated via WebSocket`);
          break;
          
        case 'subscribe':
          // Subscribe to token updates
          if (data.userId && userSessions.has(data.userId)) {
            const session = userSessions.get(data.userId);
            session.subscriptions.add(data.token);
            ws.send(JSON.stringify({ 
              type: 'subscription_success', 
              token: data.token 
            }));
            console.log(`📊 User ${data.userId} subscribed to ${data.token}`);
          }
          break;
          
        case 'unsubscribe':
          // Unsubscribe from token updates
          if (data.userId && userSessions.has(data.userId)) {
            const session = userSessions.get(data.userId);
            session.subscriptions.delete(data.token);
            ws.send(JSON.stringify({ 
              type: 'unsubscription_success', 
              token: data.token 
            }));
            console.log(`📊 User ${data.userId} unsubscribed from ${data.token}`);
          }
          break;
      }
    } catch (error) {
      console.error('❌ WebSocket message error:', error);
    }
  });
  
  ws.on('close', () => {
    // Clean up connection
    for (const [userId, session] of userSessions.entries()) {
      if (session.ws === ws) {
        userSessions.delete(userId);
        connections.delete(userId);
        console.log(`🔌 User ${userId} disconnected`);
        break;
      }
    }
  });
  
  ws.on('error', (error) => {
    console.error('❌ WebSocket error:', error);
  });
});

// Webhook endpoint for Telegram
app.post('/webhook', (req, res) => {
  try {
    const update = req.body;
    console.log('📨 Telegram webhook received:', update.message?.text || 'Update');
    
    // Process the update by emitting the message event
    if (update.message) {
      bot.emit('message', update.message);
    } else if (update.callback_query) {
      bot.emit('callback_query', update.callback_query);
    }
    
    res.status(200).send('OK');
  } catch (error) {
    console.error('❌ Webhook error:', error);
    res.status(500).send('Error');
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    activeConnections: connections.size,
    activeUsers: userSessions.size
  });
});

// Serve web interface
app.get('/', (req, res) => {
  res.sendFile(__dirname + '/public/index.html');
});

// Bot command handlers
bot.onText(/\/start/, (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  
  const welcomeMessage = `
🤖 Welcome to SolTools Dex Bot!

I'm here to help you with real-time cryptocurrency information and DexScreener data.

Choose an option below to get started:
  `;
  
  // Create inline keyboard
  const keyboard = {
    inline_keyboard: [
      [
        { text: '💰 Get Token Price', callback_data: 'price_menu' },
        { text: '🔍 Search Tokens', callback_data: 'search_menu' }
      ],
      [
        { text: '📊 Subscribe to Updates', callback_data: 'subscribe_menu' },
        { text: '📋 My Subscriptions', callback_data: 'status_menu' }
      ],
      [
        { text: '❓ Help', callback_data: 'help_menu' },
        { text: '⚙️ Settings', callback_data: 'settings_menu' }
      ],
      [
        { text: '🧪 Test Buttons', callback_data: 'test_menu' }
      ]
    ]
  };
  
  bot.sendMessage(chatId, welcomeMessage, { reply_markup: keyboard });
});

bot.onText(/\/help/, (msg) => {
  const chatId = msg.chat.id;
  const helpMessage = `
📚 Help Guide

Commands:
• /start - Welcome message with menu
• /help - Show this help
• /price <token> - Get token price (e.g., /price ETH)
• /search <query> - Search for tokens (e.g., /search Bitcoin)
• /subscribe <token> - Subscribe to real-time updates
• /unsubscribe <token> - Unsubscribe from updates
• /status - Check your subscriptions
• /keyboard - Show custom keyboard

Examples:
• /price ETH
• /search Bitcoin
• /subscribe SOL
• /unsubscribe ETH
• /status

Real-time features:
• Get instant price alerts
• Track multiple tokens
• WebSocket connection for live updates
  `;
  
  // Add custom keyboard option
  const keyboard = {
    inline_keyboard: [
      [{ text: '⌨️ Show Custom Keyboard', callback_data: 'show_keyboard' }]
    ]
  };
  
  bot.sendMessage(chatId, helpMessage, { reply_markup: keyboard });
});

bot.onText(/\/price (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const token = match[1];
  
  try {
    const loadingMsg = await bot.sendMessage(chatId, `🔍 Searching for ${token}...`);
    
    // TODO: Implement DexScreener API call here
    const response = `💰 Price information for ${token}:\n\nThis feature is coming soon! We'll integrate with DexScreener API to provide real-time price data.`;
    
    bot.editMessageText(response, {
      chat_id: chatId,
      message_id: loadingMsg.message_id
    });
    
  } catch (error) {
    console.error('Error handling price command:', error);
    bot.sendMessage(chatId, '❌ Sorry, there was an error processing your request.');
  }
});

bot.onText(/\/search (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const query = match[1];
  
  try {
    const loadingMsg = await bot.sendMessage(chatId, `🔍 Searching for "${query}"...`);
    
    // TODO: Implement DexScreener search API call here
    const response = `🔎 Search results for "${query}":\n\nThis feature is coming soon! We'll integrate with DexScreener API to provide search functionality.`;
    
    bot.editMessageText(response, {
      chat_id: chatId,
      message_id: loadingMsg.message_id
    });
    
  } catch (error) {
    console.error('Error handling search command:', error);
    bot.sendMessage(chatId, '❌ Sorry, there was an error processing your request.');
  }
});

bot.onText(/\/subscribe (.+)/, (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const token = match[1].toUpperCase();
  
  if (!userSessions.has(userId)) {
    bot.sendMessage(chatId, '❌ You need to connect via WebSocket first. Use the web interface to connect.');
    return;
  }
  
  const session = userSessions.get(userId);
  session.subscriptions.add(token);
  
  bot.sendMessage(chatId, `✅ Subscribed to ${token} updates! You'll receive real-time price alerts.`);
  console.log(`📊 User ${userId} subscribed to ${token}`);
});

bot.onText(/\/unsubscribe (.+)/, (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const token = match[1].toUpperCase();
  
  if (!userSessions.has(userId)) {
    bot.sendMessage(chatId, '❌ You need to connect via WebSocket first. Use the web interface to connect.');
    return;
  }
  
  const session = userSessions.get(userId);
  session.subscriptions.delete(token);
  
  bot.sendMessage(chatId, `✅ Unsubscribed from ${token} updates.`);
  console.log(`📊 User ${userId} unsubscribed from ${token}`);
});

bot.onText(/\/status/, (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  
  if (!userSessions.has(userId)) {
    bot.sendMessage(chatId, '❌ You need to connect via WebSocket first. Use the web interface to connect.');
    return;
  }
  
  const session = userSessions.get(userId);
  const subscriptions = Array.from(session.subscriptions);
  
  if (subscriptions.length === 0) {
    bot.sendMessage(chatId, '📊 You have no active subscriptions.');
  } else {
    const statusMessage = `📊 Your active subscriptions:\n\n${subscriptions.map(token => `• ${token}`).join('\n')}`;
    bot.sendMessage(chatId, statusMessage);
  }
});

// Test command
bot.onText(/\/test/, (msg) => {
  const chatId = msg.chat.id;
  
  const testKeyboard = {
    inline_keyboard: [
      [
        { text: '🔘 Test Button 1', callback_data: 'test_button_1' },
        { text: '🔘 Test Button 2', callback_data: 'test_button_2' }
      ],
      [
        { text: '🎯 Alert Test', callback_data: 'test_alert' },
        { text: '📊 Status Test', callback_data: 'test_status' }
      ],
      [
        { text: '💰 Price Test', callback_data: 'test_price' },
        { text: '🔍 Search Test', callback_data: 'test_search' }
      ],
      [
        { text: '🌐 WebSocket Test', callback_data: 'test_websocket' },
        { text: '📱 Notification Test', callback_data: 'test_notification' }
      ]
    ]
  };
  
  bot.sendMessage(chatId, '🧪 Test Menu\n\nChoose a test to run:\n\n• Test basic button functionality\n• Test alerts and notifications\n• Test price and search features\n• Test WebSocket connections\n• Test bot responses', {
    reply_markup: testKeyboard
  });
});

// Custom keyboard command
bot.onText(/\/keyboard/, (msg) => {
  const chatId = msg.chat.id;
  
  const customKeyboard = {
    keyboard: [
      ['💰 Price', '🔍 Search', '📊 Subscribe'],
      ['📋 Status', '❓ Help', '⚙️ Settings'],
      ['🔗 Web Interface', '🔄 Refresh']
    ],
    resize_keyboard: true,
    one_time_keyboard: false
  };
  
  bot.sendMessage(chatId, '⌨️ Custom keyboard activated! Use the buttons below for quick access:', {
    reply_markup: customKeyboard
  });
});

// Handle custom keyboard button presses
bot.on('message', (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const text = msg.text;
  
  // Skip if this is a command (let command handlers process it first)
  if (text && text.startsWith('/')) {
    return;
  }
  
  // Handle custom keyboard buttons
  if (text === '💰 Price') {
    const priceKeyboard = {
      inline_keyboard: [
        [
          { text: 'SOL', callback_data: 'price_SOL' },
          { text: 'ETH', callback_data: 'price_ETH' },
          { text: 'BTC', callback_data: 'price_BTC' }
        ],
        [
          { text: 'USDC', callback_data: 'price_USDC' },
          { text: 'USDT', callback_data: 'price_USDT' },
          { text: 'MATIC', callback_data: 'price_MATIC' }
        ]
      ]
    };
    
    bot.sendMessage(chatId, '💰 Select a token to get price information:', {
      reply_markup: priceKeyboard
    });
    return;
  }
  
  if (text === '🔍 Search') {
    bot.sendMessage(chatId, '🔍 Enter a token name or symbol to search:\n\nUse /search <token> command or type the token name directly.');
    return;
  }
  
  if (text === '📊 Subscribe') {
    const subscribeKeyboard = {
      inline_keyboard: [
        [
          { text: 'SOL', callback_data: 'subscribe_SOL' },
          { text: 'ETH', callback_data: 'subscribe_ETH' },
          { text: 'BTC', callback_data: 'subscribe_BTC' }
        ],
        [
          { text: 'USDC', callback_data: 'subscribe_USDC' },
          { text: 'USDT', callback_data: 'subscribe_USDT' },
          { text: 'MATIC', callback_data: 'subscribe_MATIC' }
        ]
      ]
    };
    
    bot.sendMessage(chatId, '📊 Select tokens to subscribe for real-time updates:', {
      reply_markup: subscribeKeyboard
    });
    return;
  }
  
  if (text === '📋 Status') {
    if (!userSessions.has(userId)) {
      bot.sendMessage(chatId, '❌ You need to connect via WebSocket first. Use the web interface to connect.');
    } else {
      const session = userSessions.get(userId);
      const subscriptions = Array.from(session.subscriptions);
      
      if (subscriptions.length === 0) {
        bot.sendMessage(chatId, '📊 You have no active subscriptions.');
      } else {
        const statusMessage = `📊 Your active subscriptions:\n\n${subscriptions.map(token => `• ${token}`).join('\n')}`;
        bot.sendMessage(chatId, statusMessage);
      }
    }
    return;
  }
  
  if (text === '❓ Help') {
    bot.sendMessage(chatId, '📚 Use /help command for detailed help information.');
    return;
  }
  
  if (text === '⚙️ Settings') {
    bot.sendMessage(chatId, '⚙️ Settings menu coming soon!\n\nFeatures planned:\n• Notification preferences\n• Price alert thresholds\n• Default tokens\n• Language settings');
    return;
  }
  
  if (text === '🔗 Web Interface') {
    bot.sendMessage(chatId, '🌐 Web Interface: http://tzen.ai\n\nUse the web interface to:\n• Connect via WebSocket\n• Manage token subscriptions\n• View real-time updates');
    return;
  }
  
  if (text === '🔄 Refresh') {
    bot.sendMessage(chatId, '🔄 Refreshing... Use /start to see the main menu again.');
    return;
  }
  




// Handle callback queries (inline keyboard buttons)
bot.on('callback_query', async (callbackQuery) => {
  const chatId = callbackQuery.message.chat.id;
  const userId = callbackQuery.from.id;
  const data = callbackQuery.data;
  
  console.log(`🔘 Callback query received: ${data} from user ${userId}`);
  
  try {
    switch (data) {
      case 'price_menu':
        const priceKeyboard = {
          inline_keyboard: [
            [
              { text: 'SOL', callback_data: 'price_SOL' },
              { text: 'ETH', callback_data: 'price_ETH' },
              { text: 'BTC', callback_data: 'price_BTC' }
            ],
            [
              { text: 'USDC', callback_data: 'price_USDC' },
              { text: 'USDT', callback_data: 'price_USDT' },
              { text: 'MATIC', callback_data: 'price_MATIC' }
            ],
            [
              { text: '🔙 Back to Main Menu', callback_data: 'main_menu' }
            ]
          ]
        };
        
        await bot.editMessageText('💰 Select a token to get price information:', {
          chat_id: chatId,
          message_id: callbackQuery.message.message_id,
          reply_markup: priceKeyboard
        });
        break;
        
      case 'search_menu':
        await bot.editMessageText('🔍 Enter a token name or symbol to search:\n\nUse /search <token> command or type the token name directly.', {
          chat_id: chatId,
          message_id: callbackQuery.message.message_id,
          reply_markup: {
            inline_keyboard: [
              [{ text: '🔙 Back to Main Menu', callback_data: 'main_menu' }]
            ]
          }
        });
        break;
        
      case 'subscribe_menu':
        const subscribeKeyboard = {
          inline_keyboard: [
            [
              { text: 'SOL', callback_data: 'subscribe_SOL' },
              { text: 'ETH', callback_data: 'subscribe_ETH' },
              { text: 'BTC', callback_data: 'subscribe_BTC' }
            ],
            [
              { text: 'USDC', callback_data: 'subscribe_USDC' },
              { text: 'USDT', callback_data: 'subscribe_USDT' },
              { text: 'MATIC', callback_data: 'subscribe_MATIC' }
            ],
            [
              { text: '🔙 Back to Main Menu', callback_data: 'main_menu' }
            ]
          ]
        };
        
        await bot.editMessageText('📊 Select tokens to subscribe for real-time updates:', {
          chat_id: chatId,
          message_id: callbackQuery.message.message_id,
          reply_markup: subscribeKeyboard
        });
        break;
        
      case 'status_menu':
        if (!userSessions.has(userId)) {
          await bot.editMessageText('❌ You need to connect via WebSocket first. Use the web interface to connect.', {
            chat_id: chatId,
            message_id: callbackQuery.message.message_id,
            reply_markup: {
              inline_keyboard: [
                [{ text: '🔙 Back to Main Menu', callback_data: 'main_menu' }]
              ]
            }
          });
        } else {
          const session = userSessions.get(userId);
          const subscriptions = Array.from(session.subscriptions);
          
          if (subscriptions.length === 0) {
            await bot.editMessageText('📊 You have no active subscriptions.', {
              chat_id: chatId,
              message_id: callbackQuery.message.message_id,
              reply_markup: {
                inline_keyboard: [
                  [{ text: '🔙 Back to Main Menu', callback_data: 'main_menu' }]
                ]
              }
            });
          } else {
            const statusMessage = `📊 Your active subscriptions:\n\n${subscriptions.map(token => `• ${token}`).join('\n')}`;
            await bot.editMessageText(statusMessage, {
              chat_id: chatId,
              message_id: callbackQuery.message.message_id,
              reply_markup: {
                inline_keyboard: [
                  [{ text: '🔙 Back to Main Menu', callback_data: 'main_menu' }]
                ]
              }
            });
          }
        }
        break;
        
      case 'help_menu':
        const helpMessage = `
📚 Help Guide

Commands:
• /start - Welcome message with menu
• /help - Show this help
• /price <token> - Get token price
• /search <query> - Search for tokens
• /subscribe <token> - Subscribe to updates
• /unsubscribe <token> - Unsubscribe from updates
• /status - Check your subscriptions

Examples:
• /price ETH
• /search Bitcoin
• /subscribe SOL
• /unsubscribe ETH
• /status

Real-time features:
• Get instant price alerts
• Track multiple tokens
• WebSocket connection for live updates
        `;
        
        await bot.editMessageText(helpMessage, {
          chat_id: chatId,
          message_id: callbackQuery.message.message_id,
          reply_markup: {
            inline_keyboard: [
              [{ text: '🔙 Back to Main Menu', callback_data: 'main_menu' }]
            ]
          }
        });
        break;
        
             case 'settings_menu':
         await bot.editMessageText('⚙️ Settings menu coming soon!\n\nFeatures planned:\n• Notification preferences\n• Price alert thresholds\n• Default tokens\n• Language settings', {
           chat_id: chatId,
           message_id: callbackQuery.message.message_id,
           reply_markup: {
             inline_keyboard: [
               [{ text: '🔙 Back to Main Menu', callback_data: 'main_menu' }]
             ]
           }
         });
         break;
         
       case 'test_menu':
         const testKeyboard = {
           inline_keyboard: [
             [
               { text: '🔘 Test Button 1', callback_data: 'test_button_1' },
               { text: '🔘 Test Button 2', callback_data: 'test_button_2' }
             ],
             [
               { text: '🎯 Alert Test', callback_data: 'test_alert' },
               { text: '📊 Status Test', callback_data: 'test_status' }
             ],
             [
               { text: '💰 Price Test', callback_data: 'test_price' },
               { text: '🔍 Search Test', callback_data: 'test_search' }
             ],
             [
               { text: '🌐 WebSocket Test', callback_data: 'test_websocket' },
               { text: '📱 Notification Test', callback_data: 'test_notification' }
             ],
             [
               { text: '🔙 Back to Main Menu', callback_data: 'main_menu' }
             ]
           ]
         };
         
         await bot.editMessageText('🧪 Test Menu\n\nChoose a test to run:\n\n• Test basic button functionality\n• Test alerts and notifications\n• Test price and search features\n• Test WebSocket connections\n• Test bot responses', {
           chat_id: chatId,
           message_id: callbackQuery.message.message_id,
           reply_markup: testKeyboard
         });
         break;
        
             case 'main_menu':
         const mainKeyboard = {
           inline_keyboard: [
             [
               { text: '💰 Get Token Price', callback_data: 'price_menu' },
               { text: '🔍 Search Tokens', callback_data: 'search_menu' }
             ],
             [
               { text: '📊 Subscribe to Updates', callback_data: 'subscribe_menu' },
               { text: '📋 My Subscriptions', callback_data: 'status_menu' }
             ],
             [
               { text: '❓ Help', callback_data: 'help_menu' },
               { text: '⚙️ Settings', callback_data: 'settings_menu' }
             ]
           ]
         };
         
         await bot.editMessageText('🤖 SolTools Dex Bot - Main Menu\n\nChoose an option below:', {
           chat_id: chatId,
           message_id: callbackQuery.message.message_id,
           reply_markup: mainKeyboard
         });
         break;
         
       case 'show_keyboard':
         const customKeyboard = {
           keyboard: [
             ['💰 Price', '🔍 Search', '📊 Subscribe'],
             ['📋 Status', '❓ Help', '⚙️ Settings'],
             ['🔗 Web Interface', '🔄 Refresh']
           ],
           resize_keyboard: true,
           one_time_keyboard: false
         };
         
         await bot.sendMessage(chatId, '⌨️ Custom keyboard activated! Use the buttons below for quick access:', {
           reply_markup: customKeyboard
         });
         break;
        
      default:
        // Handle price requests
        if (data.startsWith('price_')) {
          const token = data.replace('price_', '');
          const loadingMsg = await bot.sendMessage(chatId, `🔍 Getting price for ${token}...`);
          
          // TODO: Implement DexScreener API call here
          const response = `💰 Price information for ${token}:\n\nThis feature is coming soon! We'll integrate with DexScreener API to provide real-time price data.`;
          
          await bot.editMessageText(response, {
            chat_id: chatId,
            message_id: loadingMsg.message_id
          });
        }
        
        // Handle subscription requests
        if (data.startsWith('subscribe_')) {
          const token = data.replace('subscribe_', '');
          
          if (!userSessions.has(userId)) {
            await bot.answerCallbackQuery(callbackQuery.id, {
              text: '❌ You need to connect via WebSocket first. Use the web interface to connect.',
              show_alert: true
            });
          } else {
            const session = userSessions.get(userId);
            session.subscriptions.add(token);
            
            await bot.answerCallbackQuery(callbackQuery.id, {
              text: `✅ Subscribed to ${token} updates!`,
              show_alert: true
            });
            
            console.log(`📊 User ${userId} subscribed to ${token}`);
          }
        }
        
        // Handle test buttons
        if (data.startsWith('test_')) {
          switch (data) {
            case 'test_button_1':
              await bot.answerCallbackQuery(callbackQuery.id, {
                text: '✅ Test Button 1 works!',
                show_alert: true
              });
              break;
              
            case 'test_button_2':
              await bot.answerCallbackQuery(callbackQuery.id, {
                text: '✅ Test Button 2 works!',
                show_alert: true
              });
              break;
              
            case 'test_alert':
              await bot.answerCallbackQuery(callbackQuery.id, {
                text: '🚨 This is a test alert!',
                show_alert: true
              });
              break;
              
            case 'test_status':
              const statusMessage = `📊 Bot Status:\n\n• Server: ✅ Running\n• WebSocket: ✅ Active\n• Webhook: ✅ Configured\n• SSL: ✅ Enabled\n• Users: ${userSessions.size}\n• Connections: ${connections.size}`;
              await bot.editMessageText(statusMessage, {
                chat_id: chatId,
                message_id: callbackQuery.message.message_id,
                reply_markup: {
                  inline_keyboard: [
                    [{ text: '🔙 Back to Test Menu', callback_data: 'test_menu' }]
                  ]
                }
              });
              break;
              
            case 'test_price':
              const priceTestMessage = `💰 Price Test Results:\n\n• SOL: $123.45 (+5.67%)\n• ETH: $2,345.67 (-1.23%)\n• BTC: $45,678.90 (+2.34%)\n\nThis is simulated data for testing.`;
              await bot.editMessageText(priceTestMessage, {
                chat_id: chatId,
                message_id: callbackQuery.message.message_id,
                reply_markup: {
                  inline_keyboard: [
                    [{ text: '🔙 Back to Test Menu', callback_data: 'test_menu' }]
                  ]
                }
              });
              break;
              
            case 'test_search':
              const searchTestMessage = `🔍 Search Test Results:\n\nFound 3 tokens:\n\n1. SOL (Solana)\n   Price: $123.45\n   Market Cap: $5.2B\n\n2. SOLO (Sologenic)\n   Price: $0.45\n   Market Cap: $45M\n\n3. SOLVE (SOLVE)\n   Price: $0.12\n   Market Cap: $12M`;
              await bot.editMessageText(searchTestMessage, {
                chat_id: chatId,
                message_id: callbackQuery.message.message_id,
                reply_markup: {
                  inline_keyboard: [
                    [{ text: '🔙 Back to Test Menu', callback_data: 'test_menu' }]
                  ]
                }
              });
              break;
              
            case 'test_websocket':
              if (userSessions.has(userId)) {
                await bot.answerCallbackQuery(callbackQuery.id, {
                  text: '✅ WebSocket connected! User session active.',
                  show_alert: true
                });
              } else {
                await bot.answerCallbackQuery(callbackQuery.id, {
                  text: '❌ WebSocket not connected. Visit http://tzen.ai to connect.',
                  show_alert: true
                });
              }
              break;
              
            case 'test_notification':
              // Send a test notification
              await bot.sendMessage(chatId, '📱 Test Notification\n\nThis is a test notification to verify the bot can send messages to users.');
              await bot.answerCallbackQuery(callbackQuery.id, {
                text: '📱 Test notification sent!',
                show_alert: true
              });
              break;
          }
        }
        break;
    }
    
    // Answer callback query to remove loading state
    await bot.answerCallbackQuery(callbackQuery.id);
    
  } catch (error) {
    console.error('Error handling callback query:', error);
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: '❌ An error occurred. Please try again.',
      show_alert: true
    });
  }
});

// Handle unknown commands
bot.on('message', (msg) => {
  const chatId = msg.chat.id;
  
  if (msg.text && msg.text.startsWith('/')) {
    bot.sendMessage(chatId, '❓ Unknown command. Use /help to see available commands.');
  }
});

// Error handling
bot.on('error', (error) => {
  console.error('Bot error:', error);
});

// Function to broadcast price updates to subscribed users
function broadcastPriceUpdate(token, priceData) {
  for (const [userId, session] of userSessions.entries()) {
    if (session.subscriptions.has(token)) {
      try {
        session.ws.send(JSON.stringify({
          type: 'price_update',
          token: token,
          data: priceData,
          timestamp: Date.now()
        }));
        
        // Also send Telegram notification
        bot.sendMessage(userId, `💰 ${token} Price Update:\n${JSON.stringify(priceData, null, 2)}`);
      } catch (error) {
        console.error(`❌ Error sending update to user ${userId}:`, error);
      }
    }
  }
}

// Start the server
app.listen(PORT, () => {
  console.log(`🚀 Server running on port ${PORT}`);
  console.log(`🔌 WebSocket server running on port 8080`);
  console.log(`🤖 Bot: @soltoolsdexpaidbot`);
  console.log(`📝 Webhook URL: ${process.env.WEBHOOK_URL}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\n🛑 Shutting down gracefully...');
  wss.close();
  process.exit(0);
});
