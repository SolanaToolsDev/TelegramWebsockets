const express = require('express');
const TelegramBot = require('node-telegram-bot-api');
const WebSocket = require('ws');
const axios = require('axios');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static('public'));

// Create bot instance with webhook
const bot = new TelegramBot(process.env.BOT_TOKEN, { polling: false });

// WebSocket server for real-time updates
const wss = new WebSocket.Server({ port: 8080 });

// Store active connections
const connections = new Map();
const userSessions = new Map();

// WebSocket connection handling
wss.on('connection', (ws, req) => {
  console.log('ğŸ”Œ New WebSocket connection established');
  
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);
      console.log('ğŸ“¨ WebSocket message received:', data);
      
      // Handle different message types
      switch (data.type) {
        case 'auth':
          // Authenticate user and store connection
          const userId = data.userId;
          connections.set(userId, ws);
          userSessions.set(userId, {
            ws: ws,
            subscriptions: new Set(),
            lastActivity: Date.now()
          });
          ws.send(JSON.stringify({ type: 'auth_success', userId }));
          console.log(`âœ… User ${userId} authenticated via WebSocket`);
          break;
          
        case 'subscribe':
          // Subscribe to token updates
          if (data.userId && userSessions.has(data.userId)) {
            const session = userSessions.get(data.userId);
            session.subscriptions.add(data.token);
            ws.send(JSON.stringify({ 
              type: 'subscription_success', 
              token: data.token 
            }));
            console.log(`ğŸ“Š User ${data.userId} subscribed to ${data.token}`);
          }
          break;
          
        case 'unsubscribe':
          // Unsubscribe from token updates
          if (data.userId && userSessions.has(data.userId)) {
            const session = userSessions.get(data.userId);
            session.subscriptions.delete(data.token);
            ws.send(JSON.stringify({ 
              type: 'unsubscription_success', 
              token: data.token 
            }));
            console.log(`ğŸ“Š User ${data.userId} unsubscribed from ${data.token}`);
          }
          break;
      }
    } catch (error) {
      console.error('âŒ WebSocket message error:', error);
    }
  });
  
  ws.on('close', () => {
    // Clean up connection
    for (const [userId, session] of userSessions.entries()) {
      if (session.ws === ws) {
        userSessions.delete(userId);
        connections.delete(userId);
        console.log(`ğŸ”Œ User ${userId} disconnected`);
        break;
      }
    }
  });
  
  ws.on('error', (error) => {
    console.error('âŒ WebSocket error:', error);
  });
});

// Webhook endpoint for Telegram
app.post('/webhook', (req, res) => {
  try {
    const update = req.body;
    console.log('ğŸ“¨ Telegram webhook received:', update.message?.text || 'Update');
    
    // Process the update by emitting the message event
    if (update.message) {
      bot.emit('message', update.message);
    } else if (update.callback_query) {
      bot.emit('callback_query', update.callback_query);
    }
    
    res.status(200).send('OK');
  } catch (error) {
    console.error('âŒ Webhook error:', error);
    res.status(500).send('Error');
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    activeConnections: connections.size,
    activeUsers: userSessions.size
  });
});

// Serve web interface
app.get('/', (req, res) => {
  res.sendFile(__dirname + '/public/index.html');
});

// Bot command handlers
bot.onText(/\/start/, (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  
  const welcomeMessage = `
ğŸ¤– Welcome to SolTools Dex Bot!

I'm here to help you with real-time cryptocurrency information and DexScreener data.

Choose an option below to get started:
  `;
  
  // Create inline keyboard
  const keyboard = {
    inline_keyboard: [
      [
        { text: 'ğŸ’° Get Token Price', callback_data: 'price_menu' },
        { text: 'ğŸ” Search Tokens', callback_data: 'search_menu' }
      ],
      [
        { text: 'ğŸ“Š Subscribe to Updates', callback_data: 'subscribe_menu' },
        { text: 'ğŸ“‹ My Subscriptions', callback_data: 'status_menu' }
      ],
      [
        { text: 'â“ Help', callback_data: 'help_menu' },
        { text: 'âš™ï¸ Settings', callback_data: 'settings_menu' }
      ],
      [
        { text: 'ğŸ§ª Test Buttons', callback_data: 'test_menu' }
      ]
    ]
  };
  
  bot.sendMessage(chatId, welcomeMessage, { reply_markup: keyboard });
});

bot.onText(/\/help/, (msg) => {
  const chatId = msg.chat.id;
  const helpMessage = `
ğŸ“š Help Guide

Commands:
â€¢ /start - Welcome message with menu
â€¢ /help - Show this help
â€¢ /price <token> - Get token price (e.g., /price ETH)
â€¢ /search <query> - Search for tokens (e.g., /search Bitcoin)
â€¢ /subscribe <token> - Subscribe to real-time updates
â€¢ /unsubscribe <token> - Unsubscribe from updates
â€¢ /status - Check your subscriptions
â€¢ /keyboard - Show custom keyboard

Examples:
â€¢ /price ETH
â€¢ /search Bitcoin
â€¢ /subscribe SOL
â€¢ /unsubscribe ETH
â€¢ /status

Real-time features:
â€¢ Get instant price alerts
â€¢ Track multiple tokens
â€¢ WebSocket connection for live updates
  `;
  
  // Add custom keyboard option
  const keyboard = {
    inline_keyboard: [
      [{ text: 'âŒ¨ï¸ Show Custom Keyboard', callback_data: 'show_keyboard' }]
    ]
  };
  
  bot.sendMessage(chatId, helpMessage, { reply_markup: keyboard });
});

bot.onText(/\/price (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const token = match[1];
  
  try {
    const loadingMsg = await bot.sendMessage(chatId, `ğŸ” Searching for ${token}...`);
    
    // TODO: Implement DexScreener API call here
    const response = `ğŸ’° Price information for ${token}:\n\nThis feature is coming soon! We'll integrate with DexScreener API to provide real-time price data.`;
    
    bot.editMessageText(response, {
      chat_id: chatId,
      message_id: loadingMsg.message_id
    });
    
  } catch (error) {
    console.error('Error handling price command:', error);
    bot.sendMessage(chatId, 'âŒ Sorry, there was an error processing your request.');
  }
});

bot.onText(/\/search (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const query = match[1];
  
  try {
    const loadingMsg = await bot.sendMessage(chatId, `ğŸ” Searching for "${query}"...`);
    
    // TODO: Implement DexScreener search API call here
    const response = `ğŸ” Search results for "${query}":\n\nThis feature is coming soon! We'll integrate with DexScreener API to provide search functionality.`;
    
    bot.editMessageText(response, {
      chat_id: chatId,
      message_id: loadingMsg.message_id
    });
    
  } catch (error) {
    console.error('Error handling search command:', error);
    bot.sendMessage(chatId, 'âŒ Sorry, there was an error processing your request.');
  }
});

bot.onText(/\/subscribe (.+)/, (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const token = match[1].toUpperCase();
  
  if (!userSessions.has(userId)) {
    bot.sendMessage(chatId, 'âŒ You need to connect via WebSocket first. Use the web interface to connect.');
    return;
  }
  
  const session = userSessions.get(userId);
  session.subscriptions.add(token);
  
  bot.sendMessage(chatId, `âœ… Subscribed to ${token} updates! You'll receive real-time price alerts.`);
  console.log(`ğŸ“Š User ${userId} subscribed to ${token}`);
});

bot.onText(/\/unsubscribe (.+)/, (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const token = match[1].toUpperCase();
  
  if (!userSessions.has(userId)) {
    bot.sendMessage(chatId, 'âŒ You need to connect via WebSocket first. Use the web interface to connect.');
    return;
  }
  
  const session = userSessions.get(userId);
  session.subscriptions.delete(token);
  
  bot.sendMessage(chatId, `âœ… Unsubscribed from ${token} updates.`);
  console.log(`ğŸ“Š User ${userId} unsubscribed from ${token}`);
});

bot.onText(/\/status/, (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  
  if (!userSessions.has(userId)) {
    bot.sendMessage(chatId, 'âŒ You need to connect via WebSocket first. Use the web interface to connect.');
    return;
  }
  
  const session = userSessions.get(userId);
  const subscriptions = Array.from(session.subscriptions);
  
  if (subscriptions.length === 0) {
    bot.sendMessage(chatId, 'ğŸ“Š You have no active subscriptions.');
  } else {
    const statusMessage = `ğŸ“Š Your active subscriptions:\n\n${subscriptions.map(token => `â€¢ ${token}`).join('\n')}`;
    bot.sendMessage(chatId, statusMessage);
  }
});

// Test command
bot.onText(/\/test/, (msg) => {
  const chatId = msg.chat.id;
  
  const testKeyboard = {
    inline_keyboard: [
      [
        { text: 'ğŸ”˜ Test Button 1', callback_data: 'test_button_1' },
        { text: 'ğŸ”˜ Test Button 2', callback_data: 'test_button_2' }
      ],
      [
        { text: 'ğŸ¯ Alert Test', callback_data: 'test_alert' },
        { text: 'ğŸ“Š Status Test', callback_data: 'test_status' }
      ],
      [
        { text: 'ğŸ’° Price Test', callback_data: 'test_price' },
        { text: 'ğŸ” Search Test', callback_data: 'test_search' }
      ],
      [
        { text: 'ğŸŒ WebSocket Test', callback_data: 'test_websocket' },
        { text: 'ğŸ“± Notification Test', callback_data: 'test_notification' }
      ]
    ]
  };
  
  bot.sendMessage(chatId, 'ğŸ§ª Test Menu\n\nChoose a test to run:\n\nâ€¢ Test basic button functionality\nâ€¢ Test alerts and notifications\nâ€¢ Test price and search features\nâ€¢ Test WebSocket connections\nâ€¢ Test bot responses', {
    reply_markup: testKeyboard
  });
});

// Custom keyboard command
bot.onText(/\/keyboard/, (msg) => {
  const chatId = msg.chat.id;
  
  const customKeyboard = {
    keyboard: [
      ['ğŸ’° Price', 'ğŸ” Search', 'ğŸ“Š Subscribe'],
      ['ğŸ“‹ Status', 'â“ Help', 'âš™ï¸ Settings'],
      ['ğŸ”— Web Interface', 'ğŸ”„ Refresh']
    ],
    resize_keyboard: true,
    one_time_keyboard: false
  };
  
  bot.sendMessage(chatId, 'âŒ¨ï¸ Custom keyboard activated! Use the buttons below for quick access:', {
    reply_markup: customKeyboard
  });
});

// Handle custom keyboard button presses
bot.on('message', (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const text = msg.text;
  
  // Skip if this is a command (let command handlers process it first)
  if (text && text.startsWith('/')) {
    return;
  }
  
  // Handle custom keyboard buttons
  if (text === 'ğŸ’° Price') {
    const priceKeyboard = {
      inline_keyboard: [
        [
          { text: 'SOL', callback_data: 'price_SOL' },
          { text: 'ETH', callback_data: 'price_ETH' },
          { text: 'BTC', callback_data: 'price_BTC' }
        ],
        [
          { text: 'USDC', callback_data: 'price_USDC' },
          { text: 'USDT', callback_data: 'price_USDT' },
          { text: 'MATIC', callback_data: 'price_MATIC' }
        ]
      ]
    };
    
    bot.sendMessage(chatId, 'ğŸ’° Select a token to get price information:', {
      reply_markup: priceKeyboard
    });
    return;
  }
  
  if (text === 'ğŸ” Search') {
    bot.sendMessage(chatId, 'ğŸ” Enter a token name or symbol to search:\n\nUse /search <token> command or type the token name directly.');
    return;
  }
  
  if (text === 'ğŸ“Š Subscribe') {
    const subscribeKeyboard = {
      inline_keyboard: [
        [
          { text: 'SOL', callback_data: 'subscribe_SOL' },
          { text: 'ETH', callback_data: 'subscribe_ETH' },
          { text: 'BTC', callback_data: 'subscribe_BTC' }
        ],
        [
          { text: 'USDC', callback_data: 'subscribe_USDC' },
          { text: 'USDT', callback_data: 'subscribe_USDT' },
          { text: 'MATIC', callback_data: 'subscribe_MATIC' }
        ]
      ]
    };
    
    bot.sendMessage(chatId, 'ğŸ“Š Select tokens to subscribe for real-time updates:', {
      reply_markup: subscribeKeyboard
    });
    return;
  }
  
  if (text === 'ğŸ“‹ Status') {
    if (!userSessions.has(userId)) {
      bot.sendMessage(chatId, 'âŒ You need to connect via WebSocket first. Use the web interface to connect.');
    } else {
      const session = userSessions.get(userId);
      const subscriptions = Array.from(session.subscriptions);
      
      if (subscriptions.length === 0) {
        bot.sendMessage(chatId, 'ğŸ“Š You have no active subscriptions.');
      } else {
        const statusMessage = `ğŸ“Š Your active subscriptions:\n\n${subscriptions.map(token => `â€¢ ${token}`).join('\n')}`;
        bot.sendMessage(chatId, statusMessage);
      }
    }
    return;
  }
  
  if (text === 'â“ Help') {
    bot.sendMessage(chatId, 'ğŸ“š Use /help command for detailed help information.');
    return;
  }
  
  if (text === 'âš™ï¸ Settings') {
    bot.sendMessage(chatId, 'âš™ï¸ Settings menu coming soon!\n\nFeatures planned:\nâ€¢ Notification preferences\nâ€¢ Price alert thresholds\nâ€¢ Default tokens\nâ€¢ Language settings');
    return;
  }
  
  if (text === 'ğŸ”— Web Interface') {
    bot.sendMessage(chatId, 'ğŸŒ Web Interface: http://tzen.ai\n\nUse the web interface to:\nâ€¢ Connect via WebSocket\nâ€¢ Manage token subscriptions\nâ€¢ View real-time updates');
    return;
  }
  
  if (text === 'ğŸ”„ Refresh') {
    bot.sendMessage(chatId, 'ğŸ”„ Refreshing... Use /start to see the main menu again.');
    return;
  }
  




// Handle callback queries (inline keyboard buttons)
bot.on('callback_query', async (callbackQuery) => {
  const chatId = callbackQuery.message.chat.id;
  const userId = callbackQuery.from.id;
  const data = callbackQuery.data;
  
  console.log(`ğŸ”˜ Callback query received: ${data} from user ${userId}`);
  
  try {
    switch (data) {
      case 'price_menu':
        const priceKeyboard = {
          inline_keyboard: [
            [
              { text: 'SOL', callback_data: 'price_SOL' },
              { text: 'ETH', callback_data: 'price_ETH' },
              { text: 'BTC', callback_data: 'price_BTC' }
            ],
            [
              { text: 'USDC', callback_data: 'price_USDC' },
              { text: 'USDT', callback_data: 'price_USDT' },
              { text: 'MATIC', callback_data: 'price_MATIC' }
            ],
            [
              { text: 'ğŸ”™ Back to Main Menu', callback_data: 'main_menu' }
            ]
          ]
        };
        
        await bot.editMessageText('ğŸ’° Select a token to get price information:', {
          chat_id: chatId,
          message_id: callbackQuery.message.message_id,
          reply_markup: priceKeyboard
        });
        break;
        
      case 'search_menu':
        await bot.editMessageText('ğŸ” Enter a token name or symbol to search:\n\nUse /search <token> command or type the token name directly.', {
          chat_id: chatId,
          message_id: callbackQuery.message.message_id,
          reply_markup: {
            inline_keyboard: [
              [{ text: 'ğŸ”™ Back to Main Menu', callback_data: 'main_menu' }]
            ]
          }
        });
        break;
        
      case 'subscribe_menu':
        const subscribeKeyboard = {
          inline_keyboard: [
            [
              { text: 'SOL', callback_data: 'subscribe_SOL' },
              { text: 'ETH', callback_data: 'subscribe_ETH' },
              { text: 'BTC', callback_data: 'subscribe_BTC' }
            ],
            [
              { text: 'USDC', callback_data: 'subscribe_USDC' },
              { text: 'USDT', callback_data: 'subscribe_USDT' },
              { text: 'MATIC', callback_data: 'subscribe_MATIC' }
            ],
            [
              { text: 'ğŸ”™ Back to Main Menu', callback_data: 'main_menu' }
            ]
          ]
        };
        
        await bot.editMessageText('ğŸ“Š Select tokens to subscribe for real-time updates:', {
          chat_id: chatId,
          message_id: callbackQuery.message.message_id,
          reply_markup: subscribeKeyboard
        });
        break;
        
      case 'status_menu':
        if (!userSessions.has(userId)) {
          await bot.editMessageText('âŒ You need to connect via WebSocket first. Use the web interface to connect.', {
            chat_id: chatId,
            message_id: callbackQuery.message.message_id,
            reply_markup: {
              inline_keyboard: [
                [{ text: 'ğŸ”™ Back to Main Menu', callback_data: 'main_menu' }]
              ]
            }
          });
        } else {
          const session = userSessions.get(userId);
          const subscriptions = Array.from(session.subscriptions);
          
          if (subscriptions.length === 0) {
            await bot.editMessageText('ğŸ“Š You have no active subscriptions.', {
              chat_id: chatId,
              message_id: callbackQuery.message.message_id,
              reply_markup: {
                inline_keyboard: [
                  [{ text: 'ğŸ”™ Back to Main Menu', callback_data: 'main_menu' }]
                ]
              }
            });
          } else {
            const statusMessage = `ğŸ“Š Your active subscriptions:\n\n${subscriptions.map(token => `â€¢ ${token}`).join('\n')}`;
            await bot.editMessageText(statusMessage, {
              chat_id: chatId,
              message_id: callbackQuery.message.message_id,
              reply_markup: {
                inline_keyboard: [
                  [{ text: 'ğŸ”™ Back to Main Menu', callback_data: 'main_menu' }]
                ]
              }
            });
          }
        }
        break;
        
      case 'help_menu':
        const helpMessage = `
ğŸ“š Help Guide

Commands:
â€¢ /start - Welcome message with menu
â€¢ /help - Show this help
â€¢ /price <token> - Get token price
â€¢ /search <query> - Search for tokens
â€¢ /subscribe <token> - Subscribe to updates
â€¢ /unsubscribe <token> - Unsubscribe from updates
â€¢ /status - Check your subscriptions

Examples:
â€¢ /price ETH
â€¢ /search Bitcoin
â€¢ /subscribe SOL
â€¢ /unsubscribe ETH
â€¢ /status

Real-time features:
â€¢ Get instant price alerts
â€¢ Track multiple tokens
â€¢ WebSocket connection for live updates
        `;
        
        await bot.editMessageText(helpMessage, {
          chat_id: chatId,
          message_id: callbackQuery.message.message_id,
          reply_markup: {
            inline_keyboard: [
              [{ text: 'ğŸ”™ Back to Main Menu', callback_data: 'main_menu' }]
            ]
          }
        });
        break;
        
             case 'settings_menu':
         await bot.editMessageText('âš™ï¸ Settings menu coming soon!\n\nFeatures planned:\nâ€¢ Notification preferences\nâ€¢ Price alert thresholds\nâ€¢ Default tokens\nâ€¢ Language settings', {
           chat_id: chatId,
           message_id: callbackQuery.message.message_id,
           reply_markup: {
             inline_keyboard: [
               [{ text: 'ğŸ”™ Back to Main Menu', callback_data: 'main_menu' }]
             ]
           }
         });
         break;
         
       case 'test_menu':
         const testKeyboard = {
           inline_keyboard: [
             [
               { text: 'ğŸ”˜ Test Button 1', callback_data: 'test_button_1' },
               { text: 'ğŸ”˜ Test Button 2', callback_data: 'test_button_2' }
             ],
             [
               { text: 'ğŸ¯ Alert Test', callback_data: 'test_alert' },
               { text: 'ğŸ“Š Status Test', callback_data: 'test_status' }
             ],
             [
               { text: 'ğŸ’° Price Test', callback_data: 'test_price' },
               { text: 'ğŸ” Search Test', callback_data: 'test_search' }
             ],
             [
               { text: 'ğŸŒ WebSocket Test', callback_data: 'test_websocket' },
               { text: 'ğŸ“± Notification Test', callback_data: 'test_notification' }
             ],
             [
               { text: 'ğŸ”™ Back to Main Menu', callback_data: 'main_menu' }
             ]
           ]
         };
         
         await bot.editMessageText('ğŸ§ª Test Menu\n\nChoose a test to run:\n\nâ€¢ Test basic button functionality\nâ€¢ Test alerts and notifications\nâ€¢ Test price and search features\nâ€¢ Test WebSocket connections\nâ€¢ Test bot responses', {
           chat_id: chatId,
           message_id: callbackQuery.message.message_id,
           reply_markup: testKeyboard
         });
         break;
        
             case 'main_menu':
         const mainKeyboard = {
           inline_keyboard: [
             [
               { text: 'ğŸ’° Get Token Price', callback_data: 'price_menu' },
               { text: 'ğŸ” Search Tokens', callback_data: 'search_menu' }
             ],
             [
               { text: 'ğŸ“Š Subscribe to Updates', callback_data: 'subscribe_menu' },
               { text: 'ğŸ“‹ My Subscriptions', callback_data: 'status_menu' }
             ],
             [
               { text: 'â“ Help', callback_data: 'help_menu' },
               { text: 'âš™ï¸ Settings', callback_data: 'settings_menu' }
             ]
           ]
         };
         
         await bot.editMessageText('ğŸ¤– SolTools Dex Bot - Main Menu\n\nChoose an option below:', {
           chat_id: chatId,
           message_id: callbackQuery.message.message_id,
           reply_markup: mainKeyboard
         });
         break;
         
       case 'show_keyboard':
         const customKeyboard = {
           keyboard: [
             ['ğŸ’° Price', 'ğŸ” Search', 'ğŸ“Š Subscribe'],
             ['ğŸ“‹ Status', 'â“ Help', 'âš™ï¸ Settings'],
             ['ğŸ”— Web Interface', 'ğŸ”„ Refresh']
           ],
           resize_keyboard: true,
           one_time_keyboard: false
         };
         
         await bot.sendMessage(chatId, 'âŒ¨ï¸ Custom keyboard activated! Use the buttons below for quick access:', {
           reply_markup: customKeyboard
         });
         break;
        
      default:
        // Handle price requests
        if (data.startsWith('price_')) {
          const token = data.replace('price_', '');
          const loadingMsg = await bot.sendMessage(chatId, `ğŸ” Getting price for ${token}...`);
          
          // TODO: Implement DexScreener API call here
          const response = `ğŸ’° Price information for ${token}:\n\nThis feature is coming soon! We'll integrate with DexScreener API to provide real-time price data.`;
          
          await bot.editMessageText(response, {
            chat_id: chatId,
            message_id: loadingMsg.message_id
          });
        }
        
        // Handle subscription requests
        if (data.startsWith('subscribe_')) {
          const token = data.replace('subscribe_', '');
          
          if (!userSessions.has(userId)) {
            await bot.answerCallbackQuery(callbackQuery.id, {
              text: 'âŒ You need to connect via WebSocket first. Use the web interface to connect.',
              show_alert: true
            });
          } else {
            const session = userSessions.get(userId);
            session.subscriptions.add(token);
            
            await bot.answerCallbackQuery(callbackQuery.id, {
              text: `âœ… Subscribed to ${token} updates!`,
              show_alert: true
            });
            
            console.log(`ğŸ“Š User ${userId} subscribed to ${token}`);
          }
        }
        
        // Handle test buttons
        if (data.startsWith('test_')) {
          switch (data) {
            case 'test_button_1':
              await bot.answerCallbackQuery(callbackQuery.id, {
                text: 'âœ… Test Button 1 works!',
                show_alert: true
              });
              break;
              
            case 'test_button_2':
              await bot.answerCallbackQuery(callbackQuery.id, {
                text: 'âœ… Test Button 2 works!',
                show_alert: true
              });
              break;
              
            case 'test_alert':
              await bot.answerCallbackQuery(callbackQuery.id, {
                text: 'ğŸš¨ This is a test alert!',
                show_alert: true
              });
              break;
              
            case 'test_status':
              const statusMessage = `ğŸ“Š Bot Status:\n\nâ€¢ Server: âœ… Running\nâ€¢ WebSocket: âœ… Active\nâ€¢ Webhook: âœ… Configured\nâ€¢ SSL: âœ… Enabled\nâ€¢ Users: ${userSessions.size}\nâ€¢ Connections: ${connections.size}`;
              await bot.editMessageText(statusMessage, {
                chat_id: chatId,
                message_id: callbackQuery.message.message_id,
                reply_markup: {
                  inline_keyboard: [
                    [{ text: 'ğŸ”™ Back to Test Menu', callback_data: 'test_menu' }]
                  ]
                }
              });
              break;
              
            case 'test_price':
              const priceTestMessage = `ğŸ’° Price Test Results:\n\nâ€¢ SOL: $123.45 (+5.67%)\nâ€¢ ETH: $2,345.67 (-1.23%)\nâ€¢ BTC: $45,678.90 (+2.34%)\n\nThis is simulated data for testing.`;
              await bot.editMessageText(priceTestMessage, {
                chat_id: chatId,
                message_id: callbackQuery.message.message_id,
                reply_markup: {
                  inline_keyboard: [
                    [{ text: 'ğŸ”™ Back to Test Menu', callback_data: 'test_menu' }]
                  ]
                }
              });
              break;
              
            case 'test_search':
              const searchTestMessage = `ğŸ” Search Test Results:\n\nFound 3 tokens:\n\n1. SOL (Solana)\n   Price: $123.45\n   Market Cap: $5.2B\n\n2. SOLO (Sologenic)\n   Price: $0.45\n   Market Cap: $45M\n\n3. SOLVE (SOLVE)\n   Price: $0.12\n   Market Cap: $12M`;
              await bot.editMessageText(searchTestMessage, {
                chat_id: chatId,
                message_id: callbackQuery.message.message_id,
                reply_markup: {
                  inline_keyboard: [
                    [{ text: 'ğŸ”™ Back to Test Menu', callback_data: 'test_menu' }]
                  ]
                }
              });
              break;
              
            case 'test_websocket':
              if (userSessions.has(userId)) {
                await bot.answerCallbackQuery(callbackQuery.id, {
                  text: 'âœ… WebSocket connected! User session active.',
                  show_alert: true
                });
              } else {
                await bot.answerCallbackQuery(callbackQuery.id, {
                  text: 'âŒ WebSocket not connected. Visit http://tzen.ai to connect.',
                  show_alert: true
                });
              }
              break;
              
            case 'test_notification':
              // Send a test notification
              await bot.sendMessage(chatId, 'ğŸ“± Test Notification\n\nThis is a test notification to verify the bot can send messages to users.');
              await bot.answerCallbackQuery(callbackQuery.id, {
                text: 'ğŸ“± Test notification sent!',
                show_alert: true
              });
              break;
          }
        }
        break;
    }
    
    // Answer callback query to remove loading state
    await bot.answerCallbackQuery(callbackQuery.id);
    
  } catch (error) {
    console.error('Error handling callback query:', error);
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: 'âŒ An error occurred. Please try again.',
      show_alert: true
    });
  }
});

// Handle unknown commands
bot.on('message', (msg) => {
  const chatId = msg.chat.id;
  
  if (msg.text && msg.text.startsWith('/')) {
    bot.sendMessage(chatId, 'â“ Unknown command. Use /help to see available commands.');
  }
});

// Error handling
bot.on('error', (error) => {
  console.error('Bot error:', error);
});

// Function to broadcast price updates to subscribed users
function broadcastPriceUpdate(token, priceData) {
  for (const [userId, session] of userSessions.entries()) {
    if (session.subscriptions.has(token)) {
      try {
        session.ws.send(JSON.stringify({
          type: 'price_update',
          token: token,
          data: priceData,
          timestamp: Date.now()
        }));
        
        // Also send Telegram notification
        bot.sendMessage(userId, `ğŸ’° ${token} Price Update:\n${JSON.stringify(priceData, null, 2)}`);
      } catch (error) {
        console.error(`âŒ Error sending update to user ${userId}:`, error);
      }
    }
  }
}

// Start the server
app.listen(PORT, () => {
  console.log(`ğŸš€ Server running on port ${PORT}`);
  console.log(`ğŸ”Œ WebSocket server running on port 8080`);
  console.log(`ğŸ¤– Bot: @soltoolsdexpaidbot`);
  console.log(`ğŸ“ Webhook URL: ${process.env.WEBHOOK_URL}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\nğŸ›‘ Shutting down gracefully...');
  wss.close();
  process.exit(0);
});
